<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="编程！英语！自由！"><title> | HenryWang的小屋</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HenryWang的小屋</h1><a id="logo" href="/.">HenryWang的小屋</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/timeline/"><i class="fa fa-history"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta">2023-05-10<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="Linux-6种日志查看方法"><a href="#Linux-6种日志查看方法" class="headerlink" title="Linux 6种日志查看方法"></a>Linux 6种日志查看方法</h1><ol>
<li>tail：<ol>
<li>tail -n 10 test.log 查询日志尾部最后10行的日志; </li>
<li>tail -n +10 test.log 查询10行之后的所有日志;</li>
</ol>
</li>
<li>head：与tail相反</li>
<li>cat：由第一行到最后一行连续显示在屏幕上</li>
<li>more：可翻页</li>
<li>sed：查找特定一段<ol>
<li>sed -n ‘5,10p’ filename 这样你就可以只查看文件的第5行到第10行。</li>
</ol>
</li>
<li>less：使用less可以随意浏览文件，而more仅能向前移动，不能向后移动</li>
</ol>
<h1 id="逻辑删除和物理删除"><a href="#逻辑删除和物理删除" class="headerlink" title="逻辑删除和物理删除"></a>逻辑删除和物理删除</h1><p>逻辑删除：像一些订单<br>物理删除：操作日志</p>
<h1 id="SpringBoot定时器"><a href="#SpringBoot定时器" class="headerlink" title="SpringBoot定时器"></a>SpringBoot定时器</h1><p>在启动类中加入 @EnableScheduling 开启定时器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedu</span> &#123;</span><br><span class="line">    <span class="comment">//每五秒执行方法</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ? &quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduled</span><span class="params">()</span> &#123;</span><br><span class="line">        SimpleDateFormat formatter= <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;在 &quot;</span>+formatter.format(<span class="keyword">new</span> <span class="title class_">Date</span>())+<span class="string">&quot; 执行了方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Kafka实现消息通知"><a href="#Kafka实现消息通知" class="headerlink" title="Kafka实现消息通知"></a>Kafka实现消息通知</h1><p>比如出库操作发现仓库缺货的时候，会生成一个补货通知，将具体通知事件发送到指定的topic，然后服务会去监听这个topic，首先判断是否由收到消息，然后把收到的消息字符串转换为Event对象，然后我们将该消息经过处理存储到message数据库中。</p>
<p>打开APP主页去查询消息</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="HTTPS-执行流程"><a href="#HTTPS-执行流程" class="headerlink" title="HTTPS 执行流程"></a>HTTPS 执行流程</h2><ol>
<li>客户端使用 HTTPS 访问服务器端。</li>
<li>服务器端返回数字证书，以及使用非对称加密，生成一个公钥给客户端（私钥服务器端自己保留）。</li>
<li>客户端验证数字证书是否有效，如果无效，终止访问，如果有效： <ol>
<li>使用对称加密生成一个共享秘钥；</li>
<li>使用对称加密的共享秘钥加密数据；</li>
<li>使用非对称加密的公钥加密（对称加密生成的）共享秘钥。</li>
<li>发送加密后的秘钥和数据给服务器端。</li>
</ol>
</li>
<li>服务器端使用私钥解密出客户端（使用对称加密生成的）共享秘钥，再使用共享秘钥解密出数据的具体内容。</li>
<li>之后客户端和服务器端就使用共享秘钥加密的内容内容进行交互了。<blockquote>
<p>使用加密的方式也间接的保证了数据的完整性问题，如果是不完整的数据或有多余的数据，那么在解密时会报错，这样就能间接的保证数据的完整性了。</p>
</blockquote>
</li>
</ol>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>封装，继承，多态<br>多态：对于同一个行为，不同的子类对象具有不同的表现形式<br>比如继承了一个动物类，重写叫声这个方法，cat类就是喵喵喵，dog类就是汪汪汪</p>
<h2 id="实现多线程的几种方式"><a href="#实现多线程的几种方式" class="headerlink" title="实现多线程的几种方式"></a>实现多线程的几种方式</h2><ol>
<li>继承Thread类，重写run方法</li>
<li>实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target</li>
<li>通过Callable和FutureTask创建线程</li>
<li>通过线程池创建线程</li>
</ol>
<h1 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h1><p><strong>共同点</strong> ：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong> ：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p>TCP是面向连接的，UDP是无连接的<br>TCP是可靠的，UDP是不可靠的<br>TCP是面向字节流的，UDP是面向数据报文的<br>TCP只支持点对点通信，UDP支持一对一，一对多，多对多<br>TCP报文首部20个字节，UDP首部8个字节<br>TCP有拥塞控制机制，UDP没有<br>TCP协议下双方发送接受缓冲区都有，UDP并无实际意义上的发送缓冲区，但是存在接受缓冲区</p>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h2><ol>
<li>当多个线程对同一个集合进行操作的时候，某个线程通过iterator访问集合的时候，其他线程对这个集合进行了add，remove，clear等方法，这时候就会抛出ConcurrentModificationException异常，产生fail-fast事件。</li>
<li>在 foreach 循环里进行元素的 remove&#x2F;add 操作， foreach 语法底层其实还是依赖 Iterator 。不过， remove&#x2F;add 操作直接调用的是集合自己的方法，而不是 Iterator 的 remove&#x2F;add方法，这就导致 Iterator 莫名其妙地发现自己有元素被 remove&#x2F;add ，然后，它就会抛出一个 ConcurrentModificationException。这就是<strong>单线程状态下产生的 fail-fast 机制</strong><blockquote>
<p>可以使用CopyOnWrite（写时复制）容器避免这个问题：</p>
<p>定义：<br>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是<strong>先将当前容器进行Copy</strong>，复制出一个新的容器，然后<strong>新的容器里添加元素</strong>，添加完元素之后，<strong>再将原容器的引用指向新的容器</strong>。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种<strong>读写分离的思想</strong>，读和写不同的容器。<br>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。</p>
<p>缺点：<br>内存占用问题，由于写时复制，在进行写操作的时候内存中会存在两个对象的内存，如果这些对象占用的内存比较大，那么再写入一些新数据的时候，可能会造成Full GC</p>
</blockquote>
</li>
</ol>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ol>
<li>每一个结点都有一个颜色，要么为红色，要么为黑色；</li>
<li>树的根结点为黑色；</li>
<li>树中不存在两个相邻的红色结点（即红色结点的父结点和孩子结点均不能是红色）；</li>
<li>从任意一个结点（包括根结点）到其任何后代 NULL 结点（默认是黑色的）的每条路径都具有相同数量的黑色结点。</li>
</ol>
<h3 id="为什么要有红黑树："><a href="#为什么要有红黑树：" class="headerlink" title="为什么要有红黑树："></a>为什么要有红黑树：</h3><p>二叉排序树：<br>大多数针对二叉排序树的操作（查找，最大值，最小值，插入，删除等等）都是O(h)的时间复杂度，h为树的高度，但是对于斜树（极端情况下）会达到O(n)的复杂度。<br>平衡二叉树AVL：<br>AVL树在进行添加删除时候会存在大量的旋转操作。所以当你的应用涉及到频繁的插入和删除操作的时候请选择性能更好的红黑树；当然，如果你的应用查找操作相对更频繁，那么就优先选择 AVL 树进行实现。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h3><p>HashMap遍历的时候是无序的，和插入顺序没有关系<br>同一个HashMap在循环遍历的时候，顺序不会改变</p>
<h3 id="JDK1-8和1-7的区别"><a href="#JDK1-8和1-7的区别" class="headerlink" title="JDK1.8和1.7的区别"></a>JDK1.8和1.7的区别</h3><ol>
<li>引入红黑树解决链表过长的问题</li>
<li>重写resize方法</li>
</ol>
<h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><blockquote>
<p>HashMap 所能容纳的键值对数量</p>
</blockquote>
<p>当我们<strong>调低负载因子</strong>时，HashMap 所能<strong>容纳的键值对数量变少</strong>。扩容时，重新将键值对存储新的桶数组里，键与键之间产生的<strong>碰撞会下降，链表长度变短</strong>。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿<strong>空间换时间</strong>。<br><strong>增加负载因子</strong>（负载因子可以大于1），HashMap 所能<strong>容纳的键值对数量变多</strong>，空间利用率高，但<strong>碰撞率也高</strong>。这意味着<strong>链表长度变长</strong>，效率也随之降低，这种情况是拿<strong>时间换空间</strong>。</p>
<p>加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.<br>加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.</p>
<h3 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h3><blockquote>
<p>通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么要这样做呢？为什么不直接用键的 hashCode 方法产生的 hash 呢<br>图中的 hash 是由键的 hashCode 产生。计算余数时，由于 n 比较小，hash 只有低4位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以上图中的 hash 高4位数据与低4位数据进行异或运算，即 hash ^ (hash &gt;&gt;&gt; 4)。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。此时的计算过程如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/25657647/1672923079506-1e4fc2e8-bed1-44a5-90ad-8211d0998f78.png#averageHue=%23f6f5f5&clientId=u7ea2ba7c-26e4-4&from=paste&id=u9d7023dc&originHeight=312&originWidth=1600&originalType=url&ratio=1&rotation=0&showTitle=false&size=187385&status=done&style=none&taskId=u6215875d-eecd-4214-8b28-a2312b9e62d&title=" alt="image.png"></p>
<h3 id="为什么不使用AVL树或者B-树"><a href="#为什么不使用AVL树或者B-树" class="headerlink" title="为什么不使用AVL树或者B+树"></a>为什么不使用AVL树或者B+树</h3><p>因为AVL对于<strong>添加删除时候的旋转，相比红黑树更难实现，虽然提升速度，但是代价太大</strong><br>B和B+树主要用于<strong>数据存储在磁盘上的场景</strong>。这两种数据结构的特点就是树比较矮胖，每个结点存放一个磁盘大小的数据，这样<strong>一次可以把一个磁盘的数据读入内存，减少磁盘转动的耗时，提高效率</strong>。而<strong>红黑树多用于内存中排序，也就是内部排序</strong>。</p>
<h2 id="ConcurrentHashMap实现线程安全的方式"><a href="#ConcurrentHashMap实现线程安全的方式" class="headerlink" title="ConcurrentHashMap实现线程安全的方式"></a>ConcurrentHashMap实现线程安全的方式</h2><ul>
<li>JDK1.7时：对整个桶数组进行了分段（Segment，分段锁），每一把锁只锁容器中的一部分数据，多线程访问容器中不同数据段的数据时，不会存在锁竞争，提高效率。</li>
<li>JDK1.8时：直接使用Node数组+链表+红黑树，并发控制通过Synchronized（JDK1.6后Synchronized做了很多优化）和CAS来操作。</li>
<li>JDK1.8中，synchronized只锁定当前链表或者红黑树的首节点，这样只要hash不冲突，就不会产生并发，提升效率。</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同</p>
<ul>
<li>线程安全实现方式：JDK1.7使用Segment分段锁来实现线程安全，Segment继承自ReentrantLock。JDK1.8使用Node+CAS+Synchronized来实现线程安全，而且Synchronized只锁链表或者红黑树的首节点，锁粒度更细</li>
<li>Hash碰撞解决办法：JDK1.7使用拉链法，JDK1.8在拉链法的基础上加入了红黑树</li>
<li>并发度：JDK1.7最大并发数是Segment的个数，默认是16，JDK1.8最大并发度是Node数组的大小，并发度更大</li>
</ul>
<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：是系统进行资源分配和调度的<strong>基本单位</strong><br>线程：是系统进行资源调度的<strong>最小单位</strong></p>
<h3 id="线程拥有私有空间的意义"><a href="#线程拥有私有空间的意义" class="headerlink" title="线程拥有私有空间的意义"></a>线程拥有私有空间的意义</h3><ul>
<li>程序计数器：记录程序执行到的位置，以方便CPU切换回来能够继续从上次执行到的位置开始执行。</li>
<li>局部变量：方法中的变量，只供当前方法使用</li>
<li>方法参数：Java 方法会定义自己的入参，入参的真实值也会记录到内存空间供当前线程使用</li>
</ul>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul>
<li>NEW: 初始状态，线程被创建出来但没有被调用 start() 。</li>
<li>RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。</li>
<li>BLOCKED ：阻塞状态，需要等待锁释放。</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。（执行sleep后）</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕。</li>
</ul>
<h3 id="Java多线程-3-种创建方式："><a href="#Java多线程-3-种创建方式：" class="headerlink" title="Java多线程 3 种创建方式："></a>Java多线程 3 种创建方式：</h3><ul>
<li><strong>方式一</strong>：继承 Thread 类的方式创建线程；</li>
<li><strong>方式二</strong>：实现 java.lang.Runnable 接口；</li>
<li><strong>方式三</strong>：实现 Callable 接口。</li>
</ul>
<h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>暂停当前正在执行的线程对象（及放弃当前拥有的 cup 资源），并执行其他线程。yield () 做的是<strong>让当前运行线程回到可运行状态</strong>，以允许具有相同优先级的其他线程获得运行机会。<br>但是，实际中无法保证 yield () 达到谦让目的，因为<strong>放弃 CPU 执行权的线程还有可能被线程调度程序再次选中</strong>。</p>
<h3 id="yield-方法和-sleep-方法的区别"><a href="#yield-方法和-sleep-方法的区别" class="headerlink" title="yield 方法和 sleep 方法的区别"></a>yield 方法和 sleep 方法的区别</h3><ul>
<li>sleep () 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；</li>
<li>yield () 方法只会给相同优先级或更高优先级的线程以运行的机会；</li>
<li>线程执行 sleep () 方法后转入超时等待 (TIME_WAITING) 状态，而执行 yield () 方法后转入就绪 (ready) 状态；</li>
<li>sleep () 方法声明会抛出 InterruptedException, 而 yield () 方法没有声明任何异常；</li>
<li>sleep () 方法比 yield () 方法具有更好的移植性 (跟操作系统 CPU 调度相关)。</li>
</ul>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="乐观锁定义"><a href="#乐观锁定义" class="headerlink" title="乐观锁定义"></a>乐观锁定义</h3><p>大部分时候认为不会出现并发问题，用于读多写少的情况。通常来说是版本号机制或者CAS（compare and swap）来实现</p>
<h3 id="乐观锁存在的问题"><a href="#乐观锁存在的问题" class="headerlink" title="乐观锁存在的问题"></a>乐观锁存在的问题</h3><ol>
<li>ABA问题：解决思路是加版本号或者时间戳，AtomicStampedReference</li>
<li>循环时间长开销大：CAS通常需要自旋操作来重试，如果长时间不成功就会给CPU带来很大的开销</li>
<li>只能保证一个共享变量的原子操作：使用AtomicReference把多个共享变量合并成一个类来充当共享变量进行操作</li>
</ol>
<h2 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>synchronized，经过javac编译后，会在同步代码块前后形成monitorenter和monitorexit指令，这俩指令需要一个reference类型的参数来指明要锁定和解锁的对象，如果没有明确指明，那将根据synchronized修饰的方法类型来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程持有的锁。</p>
<p>在执行monitorenter时，首先要去获取对象的锁，如果对象没被锁定，或者当前线程已经持有这个锁了，那么会将锁计数器加一，执行monitorexit减一，如果计数器的值为0，那么锁就会被释放。如果获取对象失败，那么就会一直阻塞等待。</p>
<blockquote>
<p>synchronized是可重入锁<br>因为被synchronized修饰的线程会无条件阻止其他线程进入，所以无法强制释放锁，也无法强制中断或者超时退出</p>
</blockquote>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>无锁 —–&gt; 偏向锁  —–&gt; 轻量级锁 —–&gt; 重量级锁</p>
<h3 id="1-偏向锁-（JDK6引入，JDK15废除）"><a href="#1-偏向锁-（JDK6引入，JDK15废除）" class="headerlink" title="1. 偏向锁 （JDK6引入，JDK15废除）"></a>1. 偏向锁 （JDK6引入，JDK15废除）</h3><p>当轻量级锁（没有竞争，就自己这个线程）+ 锁重入时，<strong>每次都需要生成锁记录，并尝试CAS替换对象头的MarkWord操作</strong>。JDK6引入偏向锁做进一步优化： 第一次加锁时，不生成锁记录，将线程ID设置到锁对象的MarkWord中；之后锁重入时，<strong>检查MarkWord是否是自己的线程ID</strong>，只要不发生竞争，则可以一直使用偏向锁。</p>
<h3 id="2-自旋锁和自适应自旋锁"><a href="#2-自旋锁和自适应自旋锁" class="headerlink" title="2. 自旋锁和自适应自旋锁"></a>2. 自旋锁和自适应自旋锁</h3><p>自旋等待不能代替阻塞，虽然避免了线程切换的开销，但是浪费了CPU资源<br>JDK6中引入了自适应自旋，自旋的时间不再是固定的，而是由上次同一个锁上的自旋时间决定的。</p>
<h3 id="3-轻量级锁"><a href="#3-轻量级锁" class="headerlink" title="3. 轻量级锁"></a>3. 轻量级锁</h3><p>在代码进入同步块的时候，<strong>判断对象头Mark Word的标记位</strong>，如果没有被锁定，<strong>虚拟机将生成一个锁记录Lock Record</strong>，并尝试<strong>用CAS操作去将对象的Mark Word更新为指向当前锁记录地址</strong>，如果更新成功，则代表获得当前锁，如果更新失败，则证明至少存在一条线程与当前线程竞争获取该锁，<strong>判断当前对象的Mark Word是否指向当前锁记录地址</strong>，如果是表示当前线程已经拥有这个锁，，如果不是，则<strong>尝试进行自适应自旋，达到临界值后阻塞</strong></p>
<h3 id="4-锁消除"><a href="#4-锁消除" class="headerlink" title="4. 锁消除"></a>4. 锁消除</h3><p>虚拟机编译器运行时，对于一些代码要求同步，但是检测到不可能存在共享数据竞争的锁进行消除</p>
<h3 id="5-锁粗化"><a href="#5-锁粗化" class="headerlink" title="5. 锁粗化"></a>5. 锁粗化</h3><p>对于一系列的连续操作都对同一个对象反复加锁解锁，甚至加锁解锁操作是在循环体内的，那么即使没有线程竞争，也会造成不少的损耗，所以虚拟机会对这些操作加锁范围粗化到整个范围之外</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h3><p>一种数据结构，类似于HashMap，可以存放键值对，但只可以存放一个</p>
<h3 id="ThreadLocal和Synchronized"><a href="#ThreadLocal和Synchronized" class="headerlink" title="ThreadLocal和Synchronized"></a>ThreadLocal和Synchronized</h3><p>两者都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。<strong>Synchronized用于线程间的数据共享</strong>，而<strong>ThreadLocal则用于线程间的数据隔离</strong>。Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而<strong>ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象</strong>，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。</p>
<h3 id="ThreadLocal中的key和value"><a href="#ThreadLocal中的key和value" class="headerlink" title="ThreadLocal中的key和value"></a>ThreadLocal中的key和value</h3><p>ThreadLocal实例的弱引用对象会作为key存放在ThreadLocalMap中，然后set方法加入的值就作为ThreadLocalMap中的value，一个线程中可以new多个ThreadLocal用于存放多个值，这些值在线程内是共享的</p>
<h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>如果ThreadLocal<strong>没有外部强引用</strong>，那么在发生垃圾回收的时候，ThreadLocal就必定会被回收，而ThreadLocal又作为Map中的key，<strong>ThreadLocal被回收就会导致一个key为null的entry，外部就无法通过key来访问这个entry</strong>，垃圾回收也无法回收，这就造成了内存泄漏<br><strong>解决方案</strong><br>解决办法是每次使用完ThreadLocal都调用它的remove()方法清除数据，或者按照JDK建议将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="FixedThreadPool-固定大小线程池"><a href="#FixedThreadPool-固定大小线程池" class="headerlink" title="FixedThreadPool 固定大小线程池"></a>FixedThreadPool 固定大小线程池</h3><h4 id="FixedThreadPool-被称为可重用固定线程数的线程池"><a href="#FixedThreadPool-被称为可重用固定线程数的线程池" class="headerlink" title="FixedThreadPool 被称为可重用固定线程数的线程池"></a>FixedThreadPool 被称为可重用固定线程数的线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="为什么不推荐使用FixedThreadPool？"><a href="#为什么不推荐使用FixedThreadPool？" class="headerlink" title="为什么不推荐使用FixedThreadPool？"></a>为什么不推荐使用FixedThreadPool？</h4><p><strong>FixedThreadPool 使用无界队列 LinkedBlockingQueue（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</strong></p>
<ol>
<li>当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；</li>
<li>由于使用无界队列时 maximumPoolSize 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 FixedThreadPool的源码可以看出创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 被设置为同一个值。</li>
<li>由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数；</li>
<li>运行中的 FixedThreadPool（未执行 shutdown()或 shutdownNow()）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li>
</ol>
<h3 id="SingleThreadExecutor-单线程线程池"><a href="#SingleThreadExecutor-单线程线程池" class="headerlink" title="SingleThreadExecutor 单线程线程池"></a>SingleThreadExecutor 单线程线程池</h3><p>是只有一个线程的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">         (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="为什么不推荐使用SingleThreadExecutor？"><a href="#为什么不推荐使用SingleThreadExecutor？" class="headerlink" title="为什么不推荐使用SingleThreadExecutor？"></a>为什么不推荐使用SingleThreadExecutor？</h4><p>SingleThreadExecutor 使用无界队列 LinkedBlockingQueue 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。SingleThreadExecutor 使用无界队列作为线程池的工作队列会对线程池带来的影响与 FixedThreadPool 相同。说简单点就是可能会导致 OOM，</p>
<h3 id="CachedThreadPool-缓冲线程池"><a href="#CachedThreadPool-缓冲线程池" class="headerlink" title="CachedThreadPool  缓冲线程池"></a>CachedThreadPool  缓冲线程池</h3><p>是一个会根据需要创建新线程的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CachedThreadPool 的corePoolSize 被设置为空（0），maximumPoolSize被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 maximumPool 中线程处理任务的速度时，CachedThreadPool 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<h4 id="为什么不推荐使用CachedThreadPool？"><a href="#为什么不推荐使用CachedThreadPool？" class="headerlink" title="为什么不推荐使用CachedThreadPool？"></a>为什么不推荐使用CachedThreadPool？</h4><p>CachedThreadPool允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p><strong>ScheduledThreadPoolExecutor 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong> 这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下它的思想即可。</p>
<h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="ThreadPoolExecutor的参数"><a href="#ThreadPoolExecutor的参数" class="headerlink" title="ThreadPoolExecutor的参数"></a>ThreadPoolExecutor的参数</h3><ul>
<li><strong>corePoolSize :</strong> <strong>核心线程数</strong>，定义了最小可以同时运行的线程数量。</li>
<li><strong>maximumPoolSize :</strong> <strong>线程池的最大线程数</strong>，当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong>workQueue:</strong> <strong>任务队列</strong>，当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
<li><strong>keepAliveTime</strong>:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li>
<li><strong>unit</strong> : keepAliveTime 参数的时间单位。</li>
<li><strong>threadFactory</strong> :线程工厂，用来创建线程，一般默认即可</li>
<li><strong>handler</strong> :拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</li>
</ul>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ul>
<li><strong>AbortPolicy：</strong> 抛出 RejectedExecutionException来拒绝新任务的处理。</li>
<li><strong>CallerRunsPolicy：</strong> 将任务分给调用线程来执行,运行当前被丢弃的任务，这样做不会真的丢弃任务，但是提交的线程性能有可能急剧下降。</li>
<li><strong>DiscardPolicy：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong>DiscardOldestPolicy：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h3 id="为什么当线程池的核心线程满了后，是先加入到阻塞队列，而不是先创建新的线程？"><a href="#为什么当线程池的核心线程满了后，是先加入到阻塞队列，而不是先创建新的线程？" class="headerlink" title="为什么当线程池的核心线程满了后，是先加入到阻塞队列，而不是先创建新的线程？"></a>为什么当线程池的核心线程满了后，是先加入到阻塞队列，而不是先创建新的线程？</h3><ul>
<li>线程池创建线程需要获取mainlock这个全局锁，会影响并发效率，所以使用阻塞队列把第一步创建核心线程与第三步创建最大线程隔离开来，起一个缓冲的作用。</li>
<li>引入阻塞队列，是为了在执行execute()方法时，尽可能的避免获取全局锁。</li>
</ul>
<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25657647/1676096463960-a0be0b0e-aa9d-43b1-b21c-1d305dd1a708.png#averageHue=%23ffffff&clientId=u862f297c-8416-4&from=paste&id=SQo8J&originHeight=275&originWidth=639&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ud0269103-aa2f-4858-957c-d75e94bc5ac&title="></p>
<h3 id="如何设定线程池的大小？"><a href="#如何设定线程池的大小？" class="headerlink" title="如何设定线程池的大小？"></a>如何设定线程池的大小？</h3><ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong><br>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="线程池常用工作队列"><a href="#线程池常用工作队列" class="headerlink" title="线程池常用工作队列"></a>线程池常用工作队列</h3><ol>
<li>ArrayBlockingQueue: 是一个基于数组结构的<strong>有界阻塞队列</strong>，此队列按 FIFO（先进先出）原则对元素进行排序。 <strong>有界</strong></li>
<li>LinkedBlockingQueue: 一个基于链表结构的<strong>阻塞队列</strong>，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPo·ol()使用了这个队列。<strong>无界</strong></li>
<li>SynchronousQueue: 一个不存储元素的<strong>阻塞队列</strong>。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool（5）使用了这个队列。 <strong>无界</strong></li>
<li>PriorityBlockingQueue: 一个具有优先级的<strong>无限阻塞队列</strong>。 <strong>无界</strong></li>
</ol>
<h3 id="线程池为什么要添加空的核心线程"><a href="#线程池为什么要添加空的核心线程" class="headerlink" title="线程池为什么要添加空的核心线程"></a>线程池为什么要添加空的核心线程</h3><blockquote>
<ol>
<li>当核心线程数为0</li>
<li>核心线程超时被干掉了</li>
</ol>
</blockquote>
<p>如果阻塞队列中加入任务，但是没有核心线程，此时会添加一个空的核心线程</p>
<h3 id="线程池使用完毕为什么要调用shutdown"><a href="#线程池使用完毕为什么要调用shutdown" class="headerlink" title="线程池使用完毕为什么要调用shutdown"></a>线程池使用完毕为什么要调用shutdown</h3><ol>
<li>核心线程不会被垃圾回收，造成线程内存泄漏</li>
</ol>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><ul>
<li><strong>ConcurrentHashMap</strong> : 线程安全的 HashMap</li>
<li><strong>CopyOnWriteArrayList</strong> : 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>用于代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<blockquote>
<p>注意 ：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
</blockquote>
</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。<br>存放局部变量表和对象引用，实现方法调用</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈为虚拟机使用到的 Native 方法服务</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。<br> Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永久代(Permanent Generation)</li>
</ol>
<p>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存 </p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。<br>方法区会存储已被虚拟机加载的 <strong>元数据信息（类信息、字段信息、方法信息）、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<p>永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。<br>JDK1.4 中新加入的 <strong>NIO(New Input&#x2F;Output) 类</strong>，引入了一种基于<strong>通道（Channel）与缓存区（Buffer）的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。<br>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p>
<h3 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h3><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。<br><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>
<ul>
<li>指针碰撞 ： <ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ： <ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS</li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p>
<h4 id="内存分配并发问题（补充内容，需要掌握）"><a href="#内存分配并发问题（补充内容，需要掌握）" class="headerlink" title="内存分配并发问题（补充内容，需要掌握）"></a>内存分配并发问题（补充内容，需要掌握）</h4><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h3 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h3><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。<br><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。<br><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p>
<h2 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h2><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>当Eden区没有空间分配，虚拟机将会进行一次Minor GC</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。<br>大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h3 id="长期存活的对象直接进入老年代"><a href="#长期存活的对象直接进入老年代" class="headerlink" title="长期存活的对象直接进入老年代"></a>长期存活的对象直接进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，<strong>虚拟机给每个对象一个对象年龄（Age）计数器</strong>。<br>大部分情况，对象都会首先在 Eden 区域分配。<strong>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</strong><br><strong>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</strong>对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p>
<h3 id="针对-HotSpot-VM-的实现，它里面的-GC-其实准确分类只有两大种："><a href="#针对-HotSpot-VM-的实现，它里面的-GC-其实准确分类只有两大种：" class="headerlink" title="针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种："></a>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</h3><p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区</p>
<h3 id="死亡对象判断法"><a href="#死亡对象判断法" class="headerlink" title="死亡对象判断法"></a>死亡对象判断法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p> 通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<h5 id="哪些对象可以作为-GC-Roots-呢？"><a href="#哪些对象可以作为-GC-Roots-呢？" class="headerlink" title="哪些对象可以作为 GC Roots 呢？"></a>哪些对象可以作为 GC Roots 呢？</h5><ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<h4 id="对象可以被回收，就代表一定会被回收吗？"><a href="#对象可以被回收，就代表一定会被回收吗？" class="headerlink" title="对象可以被回收，就代表一定会被回收吗？"></a>对象可以被回收，就代表一定会被回收吗？</h4><p>即使在可达性分析法中不可达的对象，要真正宣告一个对象死亡，至少要经历两次标记过程；<strong>可达性分析法中不可达的对象被第一次标记并且进行一次筛选</strong>，筛选的条件是<strong>此对象是否有必要执行 finalize 方法</strong>。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。<br>被判定为需要执行的对象将会被<strong>放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</strong></p>
<h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>需要同时满足三个条件：</p>
<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类的Class对象没有在任何地方被引用</li>
</ul>
<h2 id="什么时候触发垃圾回收"><a href="#什么时候触发垃圾回收" class="headerlink" title="什么时候触发垃圾回收"></a>什么时候触发垃圾回收</h2><p>是JVM根据系统环境判断，自动完成的</p>
<ol>
<li>当Eden区或者S区不够用了</li>
<li>当老年代空间不够用了</li>
<li>当方法区不够用了</li>
<li>System.gc() 通知jvm进行一次垃圾回收</li>
</ol>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象<br>但是它会带来两个问题：</p>
<ol>
<li>效率问题</li>
<li>空间问题（标记清除后会产生大量不连续的碎片）</li>
</ol>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以<strong>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉</strong>。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是<strong>让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</strong>。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<h3 id="HotSpot-为什么要分为新生代和老年代"><a href="#HotSpot-为什么要分为新生代和老年代" class="headerlink" title="HotSpot 为什么要分为新生代和老年代"></a>HotSpot 为什么要分为新生代和老年代</h3><p>参考上面的分代收集算法</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong><br><strong>优点：</strong></p>
<ul>
<li><strong>简单而高效</strong></li>
<li><strong>没有线程交互的开销</strong></li>
</ul>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>Parallel Scavenge 收集器<br>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器<br><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。<br><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<h3 id="CMS-收集器（Concurrent-Mark-Sweep）回收老年代"><a href="#CMS-收集器（Concurrent-Mark-Sweep）回收老年代" class="headerlink" title="CMS 收集器（Concurrent Mark Sweep）回收老年代"></a>CMS 收集器<strong>（Concurrent Mark Sweep）回收老年代</strong></h3><p>CMS 收集器是 <strong>“标记-清除”算法</strong>实现的<br>CMS收集器是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。它非常符合在注重用户体验的应用上使用。<br>CMS收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次<strong>实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。</p>
<p>它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h3 id="G1-收集器-Garbage-First-（老年代和新生代）"><a href="#G1-收集器-Garbage-First-（老年代和新生代）" class="headerlink" title="G1 收集器**(Garbage-First)**（老年代和新生代）"></a>G1 收集器**(Garbage-First)**（老年代和新生代）</h3><p>标记整理<br>G1 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.<br>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/25657647/1676182475324-1666ea70-b712-4879-a09f-4b7d252fb89d.png#averageHue=%23f7f7f6&clientId=u6f04a875-c514-4&from=paste&id=u93116d67&originHeight=472&originWidth=693&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ueb9f98a4-2c70-408a-93b3-82f5c99caa6&title="></p>
<h2 id="类加载的流程"><a href="#类加载的流程" class="headerlink" title="类加载的流程"></a>类加载的流程</h2><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>将Class文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个该类的Class对象，作为访问的入口</li>
</ol>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul>
<li>验证：<strong>确保加载的类符合 JVM 规范和安全</strong>，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个<strong>安全检查</strong></li>
<li>准备：<strong>为static变量在方法区中分配内存空间，设置变量的初始值</strong>，例如 static int a &#x3D; 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li>
<li>解析：<strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong>（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>初始化其实就是执行类构造器方法的<clinit>()的过程</strong>，而且要保证执行前父类的<clinit>()方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 static int a 由默认初始化的0变成了显式初始化的3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p>
<blockquote>
<p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<init>和静态资源初始化的<clinit>，类构造器方法<clinit>()不同于类的构造器，这些方法都是字节码文件中只能给JVM识别的特殊方法</p>
</blockquote>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>GC将无用对象从内存中卸载</p>
<h2 id="类加载器的加载顺序"><a href="#类加载器的加载顺序" class="headerlink" title="类加载器的加载顺序"></a>类加载器的加载顺序</h2><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p>
<ol>
<li>BootStrap ClassLoader：rt.jar</li>
<li>Extension ClassLoader: 加载扩展的jar包</li>
<li>App ClassLoader：指定的classpath下面的jar包</li>
<li>Custom ClassLoader：自定义的类加载器</li>
</ol>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p> <strong>当一个类收到了加载请求时</strong>，它是不会先自己去尝试加载的，而是<strong>委派给父类去完成</strong>，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，<strong>只有当父类加载器都反馈自己无法完成这个请求</strong>（也就是父类加载器都没有找到加载所需的 Class）时，<strong>子类加载器才会自行尝试加载</strong>。</p>
<h3 id="为什么要有双亲委派"><a href="#为什么要有双亲委派" class="headerlink" title="为什么要有双亲委派"></a>为什么要有双亲委派</h3><p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 java.lang.String ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>尝试运行当前类的 main 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的java.lang.String，然而发现这个里面并没有 main 方法。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MyISAM-和-InnoDB-有什么区别"><a href="#MyISAM-和-InnoDB-有什么区别" class="headerlink" title="MyISAM 和 InnoDB 有什么区别"></a>MyISAM 和 InnoDB 有什么区别</h2><p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p>
<h3 id="是否支持行级锁"><a href="#是否支持行级锁" class="headerlink" title="是否支持行级锁"></a>是否支持行级锁</h3><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<h3 id="是否支持事务"><a href="#是否支持事务" class="headerlink" title="是否支持事务"></a>是否支持事务</h3><p>MyISAM 不提供事务支持。<br>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p>
<h3 id="是否支持外键"><a href="#是否支持外键" class="headerlink" title="是否支持外键"></a>是否支持外键</h3><p>MyISAM 不支持，而 InnoDB 支持。<br>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<h3 id="是否支持数据库异常崩溃后的安全恢复"><a href="#是否支持数据库异常崩溃后的安全恢复" class="headerlink" title="是否支持数据库异常崩溃后的安全恢复"></a>是否支持数据库异常崩溃后的安全恢复</h3><p>MyISAM 不支持，而 InnoDB 支持。<br>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <strong>redo log</strong> 。</p>
<h3 id="是否支持-MVCC"><a href="#是否支持-MVCC" class="headerlink" title="是否支持 MVCC"></a>是否支持 MVCC</h3><p>MyISAM 不支持，而 InnoDB 支持。</p>
<h3 id="索引实现不一样。"><a href="#索引实现不一样。" class="headerlink" title="索引实现不一样。"></a>索引实现不一样。</h3><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。<br>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li>
<li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li>
<li>MyISAM 不支持外键，而 InnoDB 支持。</li>
<li>MyISAM 不支持 MVVC，而 InnoDB 支持。</li>
<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>InnoDB 的性能比 MyISAM 更强大。</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>关系型数据库的事务都有ACID特性：</p>
<ul>
<li><strong>原子性</strong>（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>一个事务读取数据并进行了修改，这个修改对于其他事务可见，即使当前事务还没有提交，这时候另一个事务读取了这个数据，但第一个事务突然回滚了，那第二个事务读取到的就是脏数据。</p>
<h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
</li>
</ul>
<p>InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有两种情况<br><strong>快照读：</strong>由MVCC来保证不出现幻读<br><strong>当前读：</strong> 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="MySQL-的隔离级别是基于什么实现的？"><a href="#MySQL-的隔离级别是基于什么实现的？" class="headerlink" title="MySQL 的隔离级别是基于什么实现的？"></a>MySQL 的隔离级别是基于什么实现的？</h3><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p>
<p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>
<h3 id="MySQL-的默认隔离级别是什么"><a href="#MySQL-的默认隔离级别是什么" class="headerlink" title="MySQL 的默认隔离级别是什么?"></a>MySQL 的默认隔离级别是什么?</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过SELECT @@tx_isolation;命令来查看，MySQL 8.0 该命令改为SELECT @@transaction_isolation;</p>
<h3 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="InnoDB 有哪几类行锁？"></a>InnoDB 有哪几类行锁？</h3><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
<h2 id="MySQL执行计划"><a href="#MySQL执行计划" class="headerlink" title="MySQL执行计划"></a>MySQL执行计划</h2><p>各个字段的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>SELECT 查询的序列标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的查询类型</td>
</tr>
<tr>
<td>table</td>
<td>用到的表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为 NULL</td>
</tr>
<tr>
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>所选索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody></table>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="1-索引是什么"><a href="#1-索引是什么" class="headerlink" title="1. 索引是什么"></a>1. 索引是什么</h3><p>索引是一种能够提高数据库查询效率的数据结构，存放在磁盘中</p>
<h3 id="2-索引有哪些类型"><a href="#2-索引有哪些类型" class="headerlink" title="2. 索引有哪些类型"></a>2. 索引有哪些类型</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25657647/1676009298112-74c63cfb-b92f-4f8b-af3e-683024976df8.png#averageHue=%23f7f6f5&clientId=ub0ce09e2-9c84-4&from=paste&id=u4b5669f8&originHeight=753&originWidth=804&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9459b8d5-b683-4e61-addf-d31c04f6434&title="></p>
<h4 id="数据结构维度"><a href="#数据结构维度" class="headerlink" title="数据结构维度"></a>数据结构维度</h4><ol>
<li>B+树索引：所有数据存放在叶子节点上，复杂度为logn，支持范围查询</li>
<li>Hash索引：支持等值查询</li>
<li>全文索引：MyISAM和InnoDB都支持全文索引，一般建立在char，text，varchar上</li>
<li>R-Tree索引：用来对GIS数据类型创建SPATIAL索引</li>
</ol>
<h4 id="物理存储维度"><a href="#物理存储维度" class="headerlink" title="物理存储维度"></a>物理存储维度</h4><ol>
<li>聚簇索引：聚簇索引就是主键建立的索引，叶子节点上存放数据（InnoDB存储引擎）</li>
<li>非聚簇索引：以非主键创建的索引，在叶子节点存储的是主键和索引列。（Innodb存储引擎）</li>
</ol>
<h4 id="逻辑维度"><a href="#逻辑维度" class="headerlink" title="逻辑维度"></a>逻辑维度</h4><ol>
<li>主键索引：特殊的唯一索引，<strong>不允许有空值</strong></li>
<li>普通索引：基本索引类型，不支持空值和重复值</li>
<li>联合索引：多个字段创建的索引，使用时遵循最左匹配原则</li>
<li>唯一索引：索引列中的值必须是唯一的，但是允许为空值</li>
<li>空间索引：MySQL5.7之后支持空间索引，在空间索引这方面遵循OpenGIS几何数据模型规则。</li>
</ol>
<h3 id="3-索引什么时候会失效"><a href="#3-索引什么时候会失效" class="headerlink" title="3. 索引什么时候会失效"></a>3. 索引什么时候会失效</h3><ul>
<li>or语句前后没有使用同一个索引</li>
<li>字段类型是字符串，where时一定要用单引号括起来</li>
<li>like使用%开头，如果查询的结果中只包含主键和索引字段，也就是索引覆盖，则会使用索引，否则索引失效</li>
<li>组合索引不使用第一个列开</li>
<li>在索引列上使用is null，is not null</li>
<li>在索引字段上使用not ，&lt;&gt;， !&#x3D; 等</li>
<li>在索引列上使用函数</li>
<li>左右连接查询相关联的字段编码格式不一样，可能会导致索引失效</li>
<li>mysql估计全表扫描比索引快</li>
</ul>
<h3 id="4-哪些情况不适合建立索引"><a href="#4-哪些情况不适合建立索引" class="headerlink" title="4. 哪些情况不适合建立索引"></a>4. 哪些情况不适合建立索引</h3><ul>
<li>数据量少的表</li>
<li>更新比较频繁的字段</li>
<li>区分度低的字段，如性别</li>
<li>已经有冗余的索引情况（比如已经有a,b的联合索引，不需要再单独建立a索引）</li>
</ul>
<h3 id="5-为什么要用-B-树，为什么不用二叉树"><a href="#5-为什么要用-B-树，为什么不用二叉树" class="headerlink" title="5. 为什么要用 B+树，为什么不用二叉树"></a>5. 为什么要用 B+树，为什么不用二叉树</h3><h4 id="为什么不是一般二叉树"><a href="#为什么不是一般二叉树" class="headerlink" title="为什么不是一般二叉树"></a>为什么不是一般二叉树</h4><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找 树来说，查找效率更稳定，总体的查找速度也更快。</p>
<h4 id="为什么不是平衡二叉树"><a href="#为什么不是平衡二叉树" class="headerlink" title="为什么不是平衡二叉树"></a>为什么不是平衡二叉树</h4><p>平衡二叉树每个节点只存储一个键值和数据，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p>
<h4 id="为什么不是B树"><a href="#为什么不是B树" class="headerlink" title="为什么不是B树"></a>为什么不是B树</h4><ul>
<li><strong>B+树非叶子节点上是不存储数据的</strong>，仅存储键值，而 <strong>B 树节点中不仅存储键值，也会存储数据</strong>，innodb 中页的<strong>默认大小是 16KB</strong>，如果不存储数据，那么就<strong>会存储更多的键值</strong>，相应的树的阶数（节点的子节点树）就会更大，<strong>树就会更矮更胖</strong>，如此一来<strong>我们查找数据进行磁盘的 IO 次数又会再次减少</strong>，数据查询的效率也会更快。</li>
<li>B+树索引的所有数据均存储在叶子节点，而且数据是<strong>按照顺序排列</strong>的，链表连着的。那么 B+树使得<strong>范围查找，排序查找，分组查找以及去重查找</strong>变得异常简单。</li>
</ul>
<h3 id="6-什么是回表"><a href="#6-什么是回表" class="headerlink" title="6. 什么是回表"></a>6. 什么是回表</h3><p>当<strong>查询的数据在索引中找不到的时候</strong>，需要回到主键索引树中去获取，这个过程叫做回表。</p>
<h3 id="7-什么是覆盖索引"><a href="#7-什么是覆盖索引" class="headerlink" title="7. 什么是覆盖索引"></a>7. 什么是覆盖索引</h3><p>覆盖索引是select的数据列只用从索引中就能够取得，不必回表，换句话说，查询列要被所建的索引覆盖。</p>
<h3 id="8-什么是索引下推"><a href="#8-什么是索引下推" class="headerlink" title="8. 什么是索引下推"></a>8. 什么是索引下推</h3><p>MySQL5.6引入了索引下推，可以在索引遍历的过程中，对筛选条件中包含在索引里的字段先做判断，直接过滤掉不符合条件的记录，<strong>减少回表次数</strong></p>
<h3 id="9-大表如何添加索引"><a href="#9-大表如何添加索引" class="headerlink" title="9. 大表如何添加索引"></a>9. 大表如何添加索引</h3><blockquote>
<ol>
<li>给表添加索引的时候，是会对表加锁的</li>
</ol>
</blockquote>
<p>可以参考以下方法：</p>
<ol>
<li>先创建一张跟原表A数据结构相同的新表B。</li>
<li>在新表B添加需要加上的新索引。</li>
<li>把原表A数据导到新表B</li>
<li>重命名新表B为原表的表名A，原表A换别的表名；</li>
</ol>
<h3 id="10-Hash索引和B树索引有什么区别"><a href="#10-Hash索引和B树索引有什么区别" class="headerlink" title="10. Hash索引和B树索引有什么区别"></a>10. Hash索引和B树索引有什么区别</h3><ul>
<li>B+树可以进行范围查询，Hash 索引不能。</li>
<li>B+树支持联合索引的最左侧原则，Hash 索引不支持。</li>
<li>B+树支持 order by 排序，Hash 索引不支持。</li>
<li>Hash 索引在等值查询上比 B+树效率更高。（但是索引列的重复值很多的话，Hash冲突，效率降低）。</li>
<li>B+树使用 like 进行模糊查询的时候，like 后面（比如%开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。</li>
</ul>
<h3 id="11-索引有哪些优缺点"><a href="#11-索引有哪些优缺点" class="headerlink" title="11. 索引有哪些优缺点"></a>11. 索引有哪些优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>索引可以加快数据查询速度，减少查询时间</li>
<li>唯一索引可以保证数据库表中每一行的数据的唯一性</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>创建索引和维护索引要耗费时间</li>
<li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间</li>
<li>以表中的数据进行增、删、改的时候，索引也要动态的维护。</li>
</ul>
<h3 id="12-聚簇索引与非聚簇索引的区别"><a href="#12-聚簇索引与非聚簇索引的区别" class="headerlink" title="12. 聚簇索引与非聚簇索引的区别"></a>12. 聚簇索引与非聚簇索引的区别</h3><p><strong>InnoDB存储引擎中</strong>， 聚簇索引与非聚簇索引最大的区别，在于叶节点是否存放一整行记录。<strong>聚簇索引叶子节点存储了一整行记录</strong>，而<strong>非聚簇索引叶子节点存储的是主键信息</strong>，因此，一般<strong>非聚簇索引还需要回表查询</strong>。</p>
<ul>
<li>一个表中只能拥有一个聚集索引（因为一般聚簇索引就是主键索引），而非聚集索引一个表则可以存在多个。</li>
<li>一般来说，相对于非聚簇索引，聚簇索引查询效率更高，因为不用回表。</li>
</ul>
<p>而在MyISAM存储引擎中，它的主键索引，普通索引都是非聚簇索引，因为数据和索引是分开的，叶子节点都使用一个地址指向真正的表数据。</p>
<h3 id="13-正确使用索引的建议"><a href="#13-正确使用索引的建议" class="headerlink" title="13. 正确使用索引的建议"></a>13. 正确使用索引的建议</h3><h4 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h4><ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<h4 id="被频繁更新的字段应该慎重建立索引"><a href="#被频繁更新的字段应该慎重建立索引" class="headerlink" title="被频繁更新的字段应该慎重建立索引"></a>被频繁更新的字段应该慎重建立索引</h4><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<h4 id="尽可能的考虑建立联合索引而不是单列索引"><a href="#尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="尽可能的考虑建立联合索引而不是单列索引"></a>尽可能的考虑建立联合索引而不是单列索引</h4><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<h4 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h4><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<h4 id="考虑在字符串类型的字段上使用前缀索引代替普通索引"><a href="#考虑在字符串类型的字段上使用前缀索引代替普通索引" class="headerlink" title="考虑在字符串类型的字段上使用前缀索引代替普通索引"></a>考虑在字符串类型的字段上使用前缀索引代替普通索引</h4><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p>
<ul>
<li>使用 SELECT * 进行查询;</li>
<li>创建了组合索引，但查询条件未准守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 % 开头的 LIKE 查询比如 like ‘%abc’;;</li>
<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
<li>发生隐式转换</li>
<li>……</li>
</ul>
<h4 id="删除长期未使用的索引"><a href="#删除长期未使用的索引" class="headerlink" title="删除长期未使用的索引"></a>删除长期未使用的索引</h4><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</p>
<h2 id="为什么like-在左会导致索引失效"><a href="#为什么like-在左会导致索引失效" class="headerlink" title="为什么like %在左会导致索引失效"></a>为什么like %在左会导致索引失效</h2><p>因为b+tree索引排序规则是按照首字母去排序的，%在左导致无法得知字符串的首字母是什么</p>
<blockquote>
<p>可以使用覆盖索引来避免</p>
</blockquote>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>优点：因为结点内存储了键值和相关数据，所以把需要频繁访问的数据放在根节点附近会提高查询效率<br>缺点：如果结点中data数据较大，会导致每个结点存储Key值减少，导致B树层数变高，IO次数变多</p>
<blockquote>
<p>MongoDB使用B树</p>
</blockquote>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>优点</p>
<ul>
<li>范围搜索，因为根节点之间有引用</li>
<li>因为数据只存在于根节点，所以保存的键值相对较多，IO次数较少</li>
<li>排序能力更强</li>
</ul>
<h2 id="怎么SQL优化"><a href="#怎么SQL优化" class="headerlink" title="怎么SQL优化"></a>怎么SQL优化</h2><ol>
<li>建立索引，不要建立冗余索引，不要在经常修改的字段上建索引，不要在区分度比较小的字段上建索引</li>
<li>避免</li>
</ol>
<h2 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log（重做日志）是物理日志，记录内容是“<strong>在某个数据页上做了什么修改</strong>”，是<strong>InnoDB存储引擎独有</strong>的，它让MySQL拥有了<strong>崩溃恢复</strong>能力。<br>比如 MySQL 实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性。<br>MySQL中的数据是以页为单位的，查询一条数据，会<strong>从硬盘中把当前页加载出来</strong>，加载出来的数据叫数据页，会放入到 Buffer Pool 中。<strong>后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销</strong>，提升性能。<br><strong>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。</strong></p>
<p><strong>理想情况，事务一提交就会进行刷盘操作</strong>，但实际上，刷盘的时机是根据策略来进行的。</p>
<blockquote>
<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<h4 id="为什么不能修改后的数据直接刷盘，还需要redo-log？"><a href="#为什么不能修改后的数据直接刷盘，还需要redo-log？" class="headerlink" title="为什么不能修改后的数据直接刷盘，还需要redo log？"></a>为什么不能修改后的数据直接刷盘，还需要redo log？</h4><p>实际上，数据页大小是16KB，刷盘比较耗时，可能就修改了数据页里的几 Byte 数据，有必要把完整的数据页刷盘吗？<br>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。<br>如果是写 redo log，一行记录可能就占几十 Byte，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。<br>所以用 redo log 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>binlog 是逻辑日志，<strong>记录内容是语句的原始逻辑</strong>，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，<strong>属于MySQL Server 层。</strong><br>不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。</p>
<p>binlog 主要用来MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。<br>binlog会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<h4 id="写入时机"><a href="#写入时机" class="headerlink" title="写入时机"></a>写入时机</h4><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p> 在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。<br>为了避免写完redo log后，binlog日志写期间发生数据库异常，出现的数据不一致问题。<br>InnoDB存储引擎使用<strong>两阶段提交</strong>方案。<br>原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是<strong>两阶段提交</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/25657647/1676190635306-aac12055-7673-410f-a0a5-f09c3432c381.png#averageHue=%23d4fad4&clientId=ue8b3cee0-dbee-4&from=paste&id=uc3dc2805&originHeight=771&originWidth=851&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=uab9d44da-21c7-4b65-8390-87442eda3f4&title="></p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。<br>另外，MVCC 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</p>
<h3 id="binlog和redo-log的区别"><a href="#binlog和redo-log的区别" class="headerlink" title="binlog和redo log的区别"></a>binlog和redo log的区别</h3><ol>
<li>redo log是InnoDB独有的；binlog是MySQL的Server层实现的</li>
<li>redo log是物理日志，记录的是在xxx数据页上做了xxx修改；binlog是逻辑日志，记录的是原始逻辑，对应的SQL语句</li>
<li>redo log是循环写，空间会用完，binlog是追加写，写到一定大小会切换到下一个</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。<br>MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p>
<h2 id="InnoDB存储引擎对MVCC的实现"><a href="#InnoDB存储引擎对MVCC的实现" class="headerlink" title="InnoDB存储引擎对MVCC的实现"></a>InnoDB存储引擎对MVCC的实现</h2><h3 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h3><p>在 Repeatable Read 和 Read Committed 两个隔离级别下，如果是<strong>执行普通的 select 语句</strong>（不包括 select … lock in share mode ,select … for update）则会使用 一致性非锁定读（MVCC）。并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读</p>
<h3 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h3><p>如果执行的是下列语句，就是 锁定读（Locking Reads）</p>
<ul>
<li>select … lock in share mode</li>
<li>select … for update</li>
<li>insert、update、delete 操作</li>
</ul>
<p>在锁定读下，读取的是数据的最新版本，这种读也被称为 当前读（current read）</p>
<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><p>InnoDB 对 MVCC 的实现<br>MVCC 的实现依赖于：</p>
<ol>
<li><strong>隐藏字段</strong></li>
<li><strong>Read View</strong></li>
<li><strong>undo log</strong></li>
</ol>
<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>在内部，InnoDB 存储引擎为每行数据添加了三个隐藏字段：</p>
<ul>
<li>DB_TRX_ID（6字节）：表示<strong>最后一次插入或更新该行的事务 id</strong>。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除</li>
<li>DB_ROLL_PTR（7字节） <strong>回滚指针</strong>，<strong>指向该行的 undo log</strong> 。如果该行未被更新，则为空</li>
<li>DB_ROW_ID（6字节）：<strong>如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引</strong></li>
</ul>
<h3 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h3><p>主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p>
<h3 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo-log"></a>undo-log</h3><p>undo log 主要有两个作用：</p>
<ul>
<li>当事务回滚时用于将数据恢复到修改前的样子</li>
<li>另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，<strong>则可以通过 undo log 读取之前的版本数据，以此实现非锁定读</strong></li>
<li></li>
</ul>
<h3 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h3><p>在 InnoDB 存储引擎中，创建一个新事务后，执行每个 select 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，InnoDB 会将该记录行的 DB_TRX_ID 与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p>
<h2 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h2><p>在事务隔离级别 RC 和 RR （InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），但它们生成 Read View 的时机却不同</p>
<ul>
<li>在 RC 隔离级别下的 <strong>每次select</strong> 查询前都生成一个Read View (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 <strong>第一次select</strong> 数据前生成一个Read View（m_ids 列表）</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC是多版本并发控制，通过维护数据的多个版本，来代替锁，让不同事务可以并发执行，从而提升性能<br>读已提交下：每次查询都会生成新的ReadView，所以在<strong>读已提交</strong>隔离级别下的事务读取到的是版本链中已提交事务修改之后的数据。<br>可重复读下：只会在第一次执行查询时生成ReadView，该事务中后续的查询操作都会沿用这个ReadView，因此此隔离级别下一个事务中多次执行同样的查询，其结果都是一样的，这样就实现了可重复读。</p>
<h2 id="MVCC-Next-key-Lock-防止幻读"><a href="#MVCC-Next-key-Lock-防止幻读" class="headerlink" title="MVCC + Next-key-Lock 防止幻读"></a>MVCC + Next-key-Lock 防止幻读</h2><p>InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题：<br><strong>1、执行普通 select，此时会以 MVCC 快照读的方式读取数据</strong><br>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”<br><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong><br>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>String<br>Hash<br>List<br>Set<br>Sorted Set</p>
<h2 id="Redis可以做什么"><a href="#Redis可以做什么" class="headerlink" title="Redis可以做什么"></a>Redis可以做什么</h2><ul>
<li>缓存</li>
<li>分布式锁</li>
<li>限流</li>
<li>消息队列</li>
<li>复杂业务场景，比如通过bitmap统计活跃用户</li>
</ul>
<h2 id="Redis单线程，那怎么监听大量的客户端连接呢"><a href="#Redis单线程，那怎么监听大量的客户端连接呢" class="headerlink" title="Redis单线程，那怎么监听大量的客户端连接呢"></a>Redis单线程，那怎么监听大量的客户端连接呢</h2><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。<br>这样的好处非常明显： <strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 Selector 组件很像）。</p>
<h2 id="Redis-是如何判断数据是否过期的呢"><a href="#Redis-是如何判断数据是否过期的呢" class="headerlink" title="Redis 是如何判断数据是否过期的呢"></a>Redis 是如何判断数据是否过期的呢</h2><p> Redis 通过一个叫做<strong>过期字典</strong>（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<h2 id="过期的数据的删除策略"><a href="#过期的数据的删除策略" class="headerlink" title="过期的数据的删除策略"></a>过期的数据的删除策略</h2><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？<br>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。<br>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。<br>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>
<h2 id="Redis-内存淘汰机制了解么"><a href="#Redis-内存淘汰机制了解么" class="headerlink" title="Redis 内存淘汰机制了解么"></a>Redis 内存淘汰机制了解么</h2><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?<br>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选<strong>最近最少使用的数据</strong>淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选<strong>将要过期的数据</strong>淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中<strong>任意选择数据</strong>淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，<strong>在键空间中，移除最近最少使用的 key</strong>（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：<strong>从数据集（server.db[i].dict）中任意选择数据淘汰</strong></li>
<li><strong>no-eviction</strong>：<strong>禁止驱逐数据</strong>，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：<strong>从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</strong></li>
<li><strong>allkeys-lfu（least frequently used）</strong>：<strong>当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</strong></li>
</ol>
<h2 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h2><p>两种方式</p>
<ul>
<li>快照（RDB）</li>
<li>只追加文件（AOF）</li>
</ul>
<h3 id="快照-RDB（默认方式）"><a href="#快照-RDB（默认方式）" class="headerlink" title="快照 RDB（默认方式）"></a>快照 RDB（默认方式）</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。<br>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<h3 id="RDB-创建快照时会阻塞主线程吗？"><a href="#RDB-创建快照时会阻塞主线程吗？" class="headerlink" title="RDB 创建快照时会阻塞主线程吗？"></a>RDB 创建快照时会阻塞主线程吗？</h3><p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li>save : 主线程执行，会阻塞主线程；</li>
<li>bgsave : 子线程执行，不会阻塞主线程，默认选项。</li>
</ul>
<h3 id="什么是-AOF-持久化？"><a href="#什么是-AOF-持久化？" class="headerlink" title="什么是 AOF 持久化？"></a>什么是 AOF 持久化？</h3><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：<br><code>appendonly yes </code><br>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。<br>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。<br>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<ul>
<li>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</li>
<li>appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘</li>
<li>appendfsync no        #让操作系统决定何时进行同步</li>
</ul>
<p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<h4 id="为什么是在执行完命令之后记录日志呢？"><a href="#为什么是在执行完命令之后记录日志呢？" class="headerlink" title="为什么是在执行完命令之后记录日志呢？"></a>为什么是在执行完命令之后记录日志呢？</h4><ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）</li>
</ul>
<h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong><br>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。<br>因此，Redis 事务是不建议在日常开发中使用的。</p>
<h3 id="实现事务的方式"><a href="#实现事务的方式" class="headerlink" title="实现事务的方式"></a>实现事务的方式</h3><p>Redis + lua脚本</p>
<h2 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4><p>有哪些解决办法？<br>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h5 id="1-缓存无效key"><a href="#1-缓存无效key" class="headerlink" title="1. 缓存无效key"></a>1. 缓存无效key</h5><p><strong>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： SET key value EX 10086 。这种方式可以解决请求的 key 变化不频繁的情况</strong></p>
<h5 id="2-布隆过滤器"><a href="#2-布隆过滤器" class="headerlink" title="2. 布隆过滤器"></a>2. 布隆过滤器</h5><p>布隆过滤器是一个非常神奇的<strong>数据结构</strong>，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。<br>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<h4 id="有哪些解决办法"><a href="#有哪些解决办法" class="headerlink" title="有哪些解决办法?"></a>有哪些解决办法?</h4><ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力</strong></p>
<h4 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h4><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效（不太推荐，实用性太差）。</li>
<li>设置二级缓存</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h3 id="缓存雪崩-1"><a href="#缓存雪崩-1" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当某一个时刻出现大规模的缓存失效，那么就会导致大量请求打到数据库上，导致数据库压力过大。<br>（可能是Redis宕机，可能是采用了相同的过期时间）</p>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><ol>
<li>采用随机过期时间</li>
<li>使用熔断机制，当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示</li>
<li>搭建Redis集群</li>
</ol>
<h3 id="缓存击穿-1"><a href="#缓存击穿-1" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>一个热点的Key有大并发集中请求，突然这个Key失效了，导致大并发打到了数据库上</p>
<h4 id="解决办法：-1"><a href="#解决办法：-1" class="headerlink" title="解决办法："></a>解决办法：</h4><ol>
<li>业务允许，可以设置永不过期</li>
<li>使用互斥锁，如果缓存失效的情况，只有拿到锁才可以查询数据库</li>
</ol>
<h3 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>发送来的Key在Redis里不存在，那么就会去数据库里查询</p>
<ol>
<li>如果不存在，则给这个Key保存一个默认值</li>
<li>使用布隆过滤器，布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。</li>
</ol>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>一种数据结构，是由一串很长的二进制向量组成，可以将其看成<strong>一个二进制数组</strong>。既然是二进制，那么里面存放的不是0，就是1，但是初始默认值都是0。<strong>当要向布隆过滤器中添加一个元素key时，我们通过多个hash函数，算出一个值，然后将这个值所在的方格置为1。</strong>我们只需要将这个新的数据通过上面自定义的几个哈希函数，<strong>分别算出各个值，然后看其对应的地方是否都是1</strong>，如果存在一个不是1的情况，那么我们可以说，该新数据一定不存在于这个布隆过滤器中。</p>
<p><strong>布隆过滤器可以判断某个数据一定不存在，但是无法判断一定存在</strong>。</p>
<h3 id="解决缓存数据库一致性问题"><a href="#解决缓存数据库一致性问题" class="headerlink" title="解决缓存数据库一致性问题"></a>解决缓存数据库一致性问题</h3><h4 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h4><p>先进行缓存清除，再执行update，最后（延迟N秒）再执行缓存清除。<br>延迟双删用比较简洁的方式实现 mysql 和 redis 数据最终一致性，但它不是强一致。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br><span class="line">set key value EX 过期时间 NX</span><br></pre></td></tr></table></figure>
<h3 id="基于Redis的分布式锁的问题："><a href="#基于Redis的分布式锁的问题：" class="headerlink" title="基于Redis的分布式锁的问题："></a>基于Redis的分布式锁的问题：</h3><ol>
<li>不可重入</li>
<li>不可重试</li>
<li>超时释放，可能导致误删</li>
<li>主从一致性</li>
</ol>
<h4 id="redisson怎么解决的"><a href="#redisson怎么解决的" class="headerlink" title="redisson怎么解决的"></a>redisson怎么解决的</h4><ol>
<li>可重入：利用hash结构，记录线程id和重入次数</li>
<li>可重试：利用信号量和PubSub功能实现等待唤醒获取锁失败的重试机制</li>
<li>超时续约：利用watchDog</li>
</ol>
<h3 id="redisson看门狗"><a href="#redisson看门狗" class="headerlink" title="redisson看门狗"></a>redisson看门狗</h3><p>帮助锁续期，如果没有手动设置锁释放时间，会有看门狗机制去自动续期<br>释放锁的时候取消看门狗</p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><blockquote>
<p>依赖注入（DI）：是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建</p>
</blockquote>
<p><strong>IoC（Inversion of Control:控制反转）</strong> IoC 的思想就是<strong>将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</strong>。不过， IoC 并非 Spring 特有，在其他语言中也有应用。<br><strong>IoC 容器</strong>是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。<br>为什么叫控制反转？</p>
<ul>
<li>控制 ：指的是对象创建（实例化、管理）的权力</li>
<li>反转 ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<h3 id="IoC-解决了什么问题"><a href="#IoC-解决了什么问题" class="headerlink" title="IoC 解决了什么问题"></a>IoC 解决了什么问题</h3><ol>
<li>对象之间的耦合度或者说依赖程度降低；</li>
<li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li>
</ol>
<h2 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h2><p> AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对自己的已有方法进行增强，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<h3 id="AspectJ-定义的通知类型有哪些"><a href="#AspectJ-定义的通知类型有哪些" class="headerlink" title="AspectJ 定义的通知类型有哪些"></a>AspectJ 定义的通知类型有哪些</h3><ul>
<li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li>
<li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li>
<li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li>
<li><strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li>
</ul>
<h3 id="多个切面的执行顺序如何控制"><a href="#多个切面的执行顺序如何控制" class="headerlink" title="多个切面的执行顺序如何控制"></a>多个切面的执行顺序如何控制</h3><p>通常使用@Order 注解直接定义切面顺序，实现Ordered 接口重写 getOrder 方法。</p>
<h2 id="IOC和AOP的原理"><a href="#IOC和AOP的原理" class="headerlink" title="IOC和AOP的原理"></a>IOC和AOP的原理</h2><h3 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h3><p>spring的容器启动之后，根据xml的配置或者注解，实例化bean对象，再根据xml配置或者注解，对bean对象之间的引用关系进行依赖注入（一个bean依赖了另一个bean）<br>底层通过<strong>反射技术</strong>，直接根据你的类构建相应地对象</p>
<h3 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h3><p>spring就会通过aop机制（核心是<strong>动态代理技术</strong>）进行事务管理。<br><strong>cgclib &amp; jdk动态代理</strong></p>
<ul>
<li>如果<strong>一个类实现了某个接口</strong>，spring aop会使用<strong>jdk动态代理</strong>，生成一个实现同样的接口的代理类，构造一个实例对象出来。</li>
<li><strong>一个类没有实现接口</strong>，spring aop会改用<strong>cglib生成动态代理</strong>，其会生成一个该类的子类出来，动态生成字节码，覆盖一些方法，在方法里进行增强</li>
</ul>
<h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>推荐使用注解的方式统一异常处理，具体会使用到 @ControllerAdvice + @ExceptionHandler 这两个注解 。</p>
<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现，基于动态代理。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</li>
<li>……</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h3><ul>
<li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 TransactionTemplate或者 TransactionManager 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li>
<li><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）</li>
</ul>
<h3 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为"></a>Spring 事务中哪几种事务传播行为</h3><p><strong>1.TransactionDefinition.PROPAGATION_REQUIRED</strong><br>使用的最多的一个事务传播行为，我们平时经常使用的@Transactional注解<strong>默认使用</strong>就是这个事务传播行为。<strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</strong>。<br><strong>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</strong><br><strong>创建一个新的事务，如果当前存在事务，则把当前事务挂起</strong>。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。<br><strong>3.TransactionDefinition.PROPAGATION_NESTED</strong><br><strong>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于</strong>TransactionDefinition.PROPAGATION_REQUIRED。<br><strong>4.TransactionDefinition.PROPAGATION_MANDATORY</strong><br><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</strong>。（mandatory：强制性）<br>这个使用的很少。<br>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS</strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER</strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<h2 id="Spring自动装配"><a href="#Spring自动装配" class="headerlink" title="Spring自动装配"></a>Spring自动装配</h2><ol>
<li>包扫描</li>
<li>实例化Bean（反射）</li>
</ol>
<h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="单体应用的问题"><a href="#单体应用的问题" class="headerlink" title="单体应用的问题"></a>单体应用的问题</h2><ul>
<li><strong>部署效率低下</strong>：单体应用代码越来越多，需要的资源越来越多，打包耗费的时间就越长</li>
<li><strong>团队协作成本高</strong>：团队人数多时，代码合并一起打包部署，但凡有一个环节出问题，需要重新编译打包部署，所有相关人员参与其中，效率低下</li>
<li><strong>系统可用性差</strong>：如果一部分代码有问题，比如内存泄漏或者异常退出，那么部署在同一个JVM中的服务都不可用</li>
<li><strong>线上发布慢：</strong></li>
</ul>
<h2 id="微服务化："><a href="#微服务化：" class="headerlink" title="微服务化："></a>微服务化：</h2><p>服务化简单来说就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。</p>
<h1 id="服务化拆分"><a href="#服务化拆分" class="headerlink" title="服务化拆分"></a>服务化拆分</h1><p>这种服务化拆分方式是<strong>纵向拆分</strong>，是从<strong>业务维度</strong>进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。<br>还有一种服务化拆分方式是<strong>横向拆分</strong>，是从<strong>公共且独立功能维度</strong>拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p>
<h1 id="微服务架构6大组件："><a href="#微服务架构6大组件：" class="headerlink" title="微服务架构6大组件："></a>微服务架构6大组件：</h1><ol>
<li>服务描述：RestfulApi (http)、xml (rpc)、IDL (grpc) </li>
<li>注册中心：注册（服务提供者-&gt;注册中心）、订阅（服务消费者-&gt;注册中心）、返回（注册中心-&gt;服务消费者）、通知（注册中心-&gt;服务消费者） </li>
<li>服务框架 </li>
<li>服务监控（发现问题）：指标收集、数据处理、数据展现 </li>
<li>服务追踪（定位问题）：RequestId传递 </li>
<li>服务治理（解决问题）：单机故障——自动摘除、单IDC故障——自动切换、依赖服务不可用——熔断</li>
</ol>
<h2 id="SpringCloud全家桶"><a href="#SpringCloud全家桶" class="headerlink" title="SpringCloud全家桶"></a>SpringCloud全家桶</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25657647/1676619139178-95642354-2842-4128-a24d-318b98f6b0db.png#averageHue=%23f8f4e7&clientId=u050c4133-9f57-4&from=paste&id=u24471e5a&originHeight=1332&originWidth=2000&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=647311&status=done&style=none&taskId=ud3ad44d5-3f3c-4c01-aa23-6da06e942e4&title=" alt="image.png"></p>
<h1 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h1><h2 id="后端接口性能优化"><a href="#后端接口性能优化" class="headerlink" title="后端接口性能优化"></a>后端接口性能优化</h2><ol>
<li>优化数据库索引<ol>
<li>没加索引</li>
<li>索引失效</li>
</ol>
</li>
<li>sql优化<ol>
<li>避免使用 select *</li>
<li>小表驱动大表</li>
<li>批量操作</li>
<li>多用limit</li>
<li>in中的值不要太多</li>
<li>用连接代替子查询</li>
<li>join的表不要过多</li>
<li>注意索引数量</li>
</ol>
</li>
<li>远程调用<ol>
<li>并行调用：CompleteFuture</li>
<li>数据异构：把接口返回数据统一存放在Redis（可能存在数据一致性问题）</li>
</ol>
</li>
<li>重复调用<ol>
<li>避免循环查询数据库</li>
<li>避免死循环</li>
<li>避免无限递归</li>
</ol>
</li>
<li>异步处理：非核心逻辑，可以异步执行，异步写库<ol>
<li>线程池</li>
<li>mq</li>
</ol>
</li>
<li>避免大事务<ol>
<li>少用@Transactional注解</li>
<li>将查询(select)方法放到事务外</li>
<li>事务中避免远程调用</li>
<li>事务中避免一次性处理太多数据</li>
<li>有些功能可以非事务执行</li>
<li>有些功能可以异步处理</li>
</ol>
</li>
<li>注意锁粒度</li>
<li>加缓存<ol>
<li>Redis缓存</li>
<li>Redis缓存 + 二级缓存（内存中）</li>
</ol>
</li>
<li>分库分表</li>
<li>辅助功能</li>
<li>开启慢查询日志</li>
</ol>
<ul>
<li>slow_query_log 慢查询开关</li>
<li>slow_query_log_file 慢查询日志存放的路径</li>
<li>long_query_time 超过多少秒才会记录日志</li>
</ul>
<ol start="2">
<li>加监控：Prometheus</li>
<li>链路跟踪：skywalking</li>
</ol>
<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><h2 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h2><h3 id="Offer30：包含min函数的栈"><a href="#Offer30：包含min函数的栈" class="headerlink" title="Offer30：包含min函数的栈"></a>Offer30：包含min函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比如 -2 3 10 -3</span></span><br><span class="line">        <span class="comment">// 将-3弹出后，必须将10,3都弹出才可以弹出下一个最小值-2，所以可以过滤掉3,10不push</span></span><br><span class="line">        <span class="comment">// 注意这里的 = ，如果有两个最小值，比如 -2，-2，-3，必须将两个都push到minStack</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || x &lt;= minStack.peek()) &#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.pop().equals(minStack.peek())) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2023/03/04/Netty%E5%BC%80%E7%AB%AF/">Netty开端</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://jasonle.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>编程！英文！自由！</p><a class="info-icon" href="https://twitter.com/HenryWang62" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="2461251662@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-email-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/JasonLe" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Netty/" style="font-size: 15px;">Netty</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/05/10/2023-%E9%9D%A2%E8%AF%95%E9%A2%98/">2023-面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/04/Netty%E5%BC%80%E7%AB%AF/">Netty开端</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">HenryWang的小屋.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="50" src="//lib.baomitu.com/canvas-nest.js/latest/canvas-nest.js"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>